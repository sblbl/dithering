<link rel="stylesheet" href="/assets/styles.css">

# Loyd Steinberg Error Diffusion Dithering Script

Just a handcrafted script for image dithering, not generated by AI ðŸ‘Œ

![pingu painting](https://c.tenor.com/xP_nPC9TBYYAAAAd/tenor.gif)

## Instructions

```
cd [REPO]
python3 dither.py [IMAGE_PATH]
```

## How it works

Image dithering is a processing technique that, usually, converts a color or grayscale image into a black and white one. Transformations like dithering treat images as bidimensional matrixes with a number of columns and rows equal to their width and height. Each element in this matrix contains the color value of one pixel.

The most naÃ¯ve approach for dithering is _threshold_, that simply convert a pixel value to black (0) or white (255) according to its value with respect of a threshold (usually 128, half of the number of gray tones that is 256). This strategy, however, produces high-contrast images where a lot of detail is lost.

Dithering with error diffusion, instead, diffuses the _quantisation error_ among pixels, that is the error of the approximation from grayscale to bitmap of a pixel is distributed among the surrounding pixels. Many error diffusion methods are available, and among them one of the most used is Loyd-Steinberg dithering.

<table>
  <caption>
    Dithering techniques in comparison
  </caption>
    <thead>
        <tr>
            <th scope="col">original</th>
            <th scope="col">threshold</th>
            <th scope="col">error diffusion</th>
        </tr>
        <tbody>
            <tr>
                <td><img src="/assets/original.jpeg"></td>
                <td><img src="/assets/threshold.png"></td>
                <td><img src="/assets/dithered.png"></td>
            </tr>
        </tbody>
  </thead>
</table>

### Loyd Steinberg dithering

An image can be represented as a matrix of pixels. The following, for example, is a 5 x 5 pixels image.
Each pixels contains 3 values, (R, G, B), from 0 to 255, that represent the amount of Red, Green and Blue in that pixel. The values of these 3 primary colors, combined, create in the human eye the perception of a wide range of tones.
Usually we refer to primary colors as red, yellow, and blue, but screens are built differently and produce green light instead of yellow.

<div style="text-align: center; width: 60%; margin: auto;">
  <img src="/assets/image-as-matrix.svg" alt="image as matrix">
</div>

> <p style="font-size: 12px;">Each pixel of an image is a cell in a bidimensional matrix. However, the pixel itself has 3 dimensions. </p>

In a way, the R, G, and B channels can be seen as different layers of a picture, or filters able to react to the light. From an RGB image matrix we can separate the three color channels and see how each color contributes to the whole picture.

<img src="/assets/example-channels.png" alt="channels">

> <p style="font-size: 12px;">Views of the same picture's Red, Green, and Blue channels: darker areas are where a color is most promininent</p>

#### RGB to grayscale

In order to simplest perform the Loyd Steinberg error diffusion algorithm, however, it's better to work on a single level, or channel. In order not to loose too much visual information it's usually better to convert the picture data from RGB into grayscale. For every pixel in every channel, the mean of the R, G, and B values respectively (all between 0 and 255) is performed. In this way, we pass from a matrix of shape (image_width, image_heigth, 3) to one of shape (image_width, image_heigth, 1). There are other methods to convert RGB to grayscale, but mean is one of the most intuitive.

<img src="/assets/example-rgb-to-grayscale.svg" alt="grayscale conversion">

> <p style="font-size: 12px;">RGB colors (top) converted to grayscale by calculating the mean of the R, G, and B values (bottom)</p>

#### Color thresholding

Each pixel is parsed once at a time. First, of all, the pixel value (0-255) is parsed via a threshold funciton, where the threshold is 128 (256/2): if the value is less than it, it becomes black (0), otherwise white (255).

#### Error computation

Since after threshold some tone information is lost because the original pixel value is approximated to 0 or 255, an error value is calculated, that is the difference between the sampled value and the original one.

#### Error diffusion

The error value for that pixel is spreaded among the 4 surrounding pixels that still haven't been parsed: the next to the right, the one right at the bottom, and the ones on the bottom left and right. The error value is distributed in respectively <sup>7</sup>&frasl;<sub>16</sub> (right), <sup>3</sup>&frasl;<sub>16</sub> (bottom left), <sup>5</sup>&frasl;<sub>16</sub> (bottom), <sup>1</sup>&frasl;<sub>16</sub> (bottom right). The sum of the splitted errors is <sup>16</sup>&frasl;<sub>16</sub> = 1. These values are what distinguishes Loyd Steinberg's algorithm.

<div style="text-align: center; width: 50%; margin: auto;">
  <img src="/assets/error-diffusion-matrix.svg" alt="error diffusion">
</div>

> <p style="font-size: 12px;">The yellow cell represents the current pixel, whose error has been calculated. </br> The purple cells are those pixels that will be affected by the error propagation</p>

#### The algorithm in practice

Loyd-Steinberg error diffusion dithering proceeds from left to right, and from top to bottom of an image, one pixel at a time, calculating the error for that pixel and distributing it among the surrounding next pixels.

<img src="/assets/matrix-processing.gif" alt="processing order">

> <p style="font-size: 12px;">This animation highlights how the iteration proceeds: once a pixel is modified via threshold, it will never change again: This is the meaning of error distribution.</p>

<table>
    <thead>
        <tbody>
            <tr>
                <td><img  src="/assets/original.jpeg" alt="original"></td>
                <td><img  src="/assets/timelapse.gif" alt="timelapse"></td>
            </tr>
        </tbody>
  </thead>
   <tr>
            <th scope="col">original</th>
            <th scope="col">dithering</th>    
        </tr>
</table>

> <p style="font-size: 12px;">Simplified demonstration of how a dithered image is generated: one line and one pixel at a time, from top-left to bottom-right. The animation is generated from a 42x42px reduction of the original image</p>

## The matrix filter analogy

To better understand how this algorithm works, the concept of an Error Matrix positioned as a filter on top of the image matrix might be useful. Instead of thinking about diffusing error information directly on the image, we can think about having a matrix of the same size of the image and on top of it. This matrix, for each pixel (cell), will keep track of all the error propagation data coming from previous and contiguous other pixels. In such a way, when it's time to parse a specific pixel, it's sufficient to add the error value from the error matrix, compute the new value and finally update the error matrix again.
